# backend/app.py
"""
FastAPI service: accept GDScript+Scene input -> assemble Godot project -> export WebGL/APK -> return download links.
Run:
  pip install fastapi uvicorn pydantic aiofiles httpx python-multipart
  uvicorn backend.app:app --host 0.0.0.0 --port 8000
Environment variables:
  GODOT_CLI -> path to godot executable (default: /usr/bin/godot)
  WORKDIR -> where to create projects (default: /tmp/ai_game_builder)
Note: For APK/WebGL export, Godot export templates & Android SDK must be installed and export_presets.cfg configured in project.
"""

import os
import shutil
import uuid
import json
import asyncio
from typing import Dict, List, Optional
from pydantic import BaseModel
from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse, JSONResponse

GODOT_CLI = os.getenv("GODOT_CLI", "/usr/bin/godot")
WORKDIR = os.getenv("WORKDIR", "/tmp/ai_game_builder")
os.makedirs(WORKDIR, exist_ok=True)

app = FastAPI(title="GDScript->Godot Build Service")

# ---------------------
# Models
# ---------------------
class BuildRequest(BaseModel):
    project_name: Optional[str] = "ai_game"
    scenes: Optional[Dict[str, str]] = {}       # filename -> .tscn content (text)
    scripts: Optional[Dict[str, str]] = {}      # filename -> .gd content (text)
    main_scene: Optional[str] = None            # e.g., "scenes/Main.tscn"
    exports: Optional[List[str]] = ["webgl"]    # allowed: "webgl", "apk", "none"

class BuildResponse(BaseModel):
    job_id: str
    status: str
    artifacts: Dict[str, str]  # name -> download URL
    build_log: Optional[Dict[str, str]] = None

# ---------------------
# Helpers
# ---------------------
def make_job_dir(base_name: str):
    job_id = f"{base_name}_{uuid.uuid4().hex[:8]}"
    path = os.path.join(WORKDIR, job_id)
    os.makedirs(path, exist_ok=True)
    return job_id, path

def write_text_file(path: str, content: str):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

def create_minimal_project(project_dir: str, main_scene: Optional[str]):
    # Minimal project.godot (very simple placeholder)
    proj_path = os.path.join(project_dir, "project.godot")
    project_godot = (
        "[gd_resource type=\"ConfigFile\"]\n"
        "; minimal project generated by ai-builder\n"
    )
    write_text_file(proj_path, project_godot)

    # If main_scene provided, write autoload or note in README (Godot uses project settings in editor)
    if main_scene:
        write_text_file(os.path.join(project_dir, "README_MAIN_SCENE.txt"), f"Main scene: {main_scene}\n")

async def run_godot_export(project_dir: str, export: str):
    """
    Attempt to run Godot headless export.
    Requires:
      - Godot CLI installed & accessible (GODOT_CLI)
      - export_presets.cfg present in project_dir configured with targets "HTML5" and/or "Android"
      - For Android: Android SDK & signing configured in export_presets
    Returns dict with returncode, stdout, stderr, out_path (if success)
    """
    if export not in ("webgl", "apk"):
        return {"error": f"invalid export target: {export}"}

    build_dir = os.path.join(project_dir, "build")
    os.makedirs(build_dir, exist_ok=True)

    if export == "webgl":
        # The export name used in editor should typically be "HTML5" or "Web"
        out_file = os.path.join(build_dir, "index.html")
        cmd = [GODOT_CLI, "--headless", "--export", "HTML5", out_file]
    else:
        out_file = os.path.join(build_dir, f"{os.path.basename(project_dir)}.apk")
        cmd = [GODOT_CLI, "--headless", "--export", "Android", out_file]

    # Verify godot exists
    if not shutil.which(GODOT_CLI):
        return {"error": f"Godot CLI not found at '{GODOT_CLI}' (ensure GODOT_CLI env var or binary on PATH)"}

    proc = await asyncio.create_subprocess_exec(*cmd, cwd=project_dir,
                                                stdout=asyncio.subprocess.PIPE,
                                                stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    return {
        "returncode": proc.returncode,
        "stdout": stdout.decode(errors="ignore"),
        "stderr": stderr.decode(errors="ignore"),
        "out_file": out_file if proc.returncode == 0 else None
    }

def archive_result(src_dir: str, dest_zip: str):
    # dest_zip without .zip extension -> shutil.make_archive wants base name
    base = dest_zip.replace(".zip", "")
    shutil.make_archive(base, 'zip', src_dir)
    return dest_zip

# ---------------------
# Endpoints
# ---------------------
@app.post("/build", response_model=BuildResponse)
async def build(req: BuildRequest):
    """
    POST JSON:
    {
      "project_name":"mygame",
      "scenes":{"scenes/Main.tscn":"[gd_scene ...]"},
      "scripts":{"scripts/main.gd":"extends Node\n..."},
      "main_scene":"scenes/Main.tscn",
      "exports":["webgl","apk"]
    }
    Response contains job_id, artifact download URLs, and build logs/state.
    """
    job_id, project_dir = make_job_dir(req.project_name)
    try:
        # 1) create minimal project structure
        create_minimal_project(project_dir, req.main_scene)

        # 2) write scenes
        for fname, content in (req.scenes or {}).items():
            # ensure path is inside project_dir
            path = os.path.join(project_dir, fname)
            write_text_file(path, content)

        # 3) write scripts
        for fname, content in (req.scripts or {}).items():
            path = os.path.join(project_dir, fname)
            write_text_file(path, content)

        # 4) Write a simple export_presets.cfg placeholder if not present
        # NOTE: For real build exports, you must prepare export_presets.cfg in Godot editor and include templates.
        preset_path = os.path.join(project_dir, "export_presets.cfg")
        if not os.path.exists(preset_path):
            sample_preset = (
                "; NOTE: This is only a placeholder. For actual exports you must configure export templates in the editor.\n"
                "[preset.0]\n"
                "name=\"HTML5\"\n"
                "platform=\"HTML5\"\n\n"
                "[preset.1]\n"
                "name=\"Android\"\n"
                "platform=\"Android\"\n"
            )
            write_text_file(preset_path, sample_preset)

        # 5) Attempt builds
        artifacts = {}
        build_log = {}
        for export_target in (req.exports or []):
            if export_target == "none":
                continue
            info = await run_godot_export(project_dir, export_target)
            build_log[export_target] = {"info": info}
            # If build succeeded and out_file exists, copy to a known artifacts dir and make a zip link
            out_file = info.get("out_file")
            if out_file and os.path.exists(out_file):
                # copy artifact to public folder under WORKDIR/artifacts/
                artifacts_dir = os.path.join(WORKDIR, "artifacts")
                os.makedirs(artifacts_dir, exist_ok=True)
                # name artifacts with job_id prefix
                dst_name = f"{job_id}_{os.path.basename(out_file)}"
                dst_path = os.path.join(artifacts_dir, dst_name)
                shutil.copy2(out_file, dst_path)
                artifacts[export_target] = f"/download_artifact/{dst_name}"

        # 6) Always zip the full project for download
        zip_name = f"{job_id}_project.zip"
        zip_path = os.path.join(WORKDIR, "artifacts", zip_name)
        os.makedirs(os.path.dirname(zip_path), exist_ok=True)
        archive_result(project_dir, zip_path)
        artifacts["project_zip"] = f"/download_artifact/{zip_name}"

        return BuildResponse(job_id=job_id, status="done", artifacts=artifacts, build_log=build_log)
    except Exception as e:
        # cleanup maybe but keep artifacts for debugging
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/download_artifact/{name}")
async def download_artifact(name: str):
    path = os.path.join(WORKDIR, "artifacts", name)
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail="Artifact not found")
    # choose content-type automatically by FileResponse
    return FileResponse(path, filename=name)

@app.get("/health")
def health():
    return {"status": "ok", "workdir": WORKDIR, "godot_cli": GODOT_CLI if shutil.which(GODOT_CLI) else "NOT_FOUND"}
